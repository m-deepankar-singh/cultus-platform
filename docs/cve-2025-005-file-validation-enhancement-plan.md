# CVE-2025-005: Weak File Type Validation - Implementation Plan

## Security Issue Summary

**CVE ID:** CVE-2025-005  
**Title:** Weak File Type Validation  
**Severity:** Medium-High  
**Status:** In Progress  

### Vulnerability Description

The current file upload system relies exclusively on browser-provided MIME types for file validation. This approach is fundamentally insecure because:

1. **MIME Type Spoofing:** Attackers can easily modify HTTP headers to claim malicious files are legitimate
2. **No Binary Validation:** Files are not inspected at the binary level to verify their actual format
3. **Content Bypass:** Malicious payloads can be embedded in otherwise legitimate file formats
4. **Insufficient SVG Validation:** SVG files can contain JavaScript and XSS vectors

### Current Implementation Analysis

**Affected Files:**
- `app/api/admin/clients/upload-logo/route.ts` - Logo uploads (MIME: `image/*`)
- `app/api/admin/lessons/upload-video/route.ts` - Video uploads (MIME: `video/*`)
- `app/api/r2/presigned-upload/route.ts` - Presigned uploads with type validation
- `lib/r2/simple-upload-service.ts` - Core validation logic

**Current Validation Logic:**
```typescript
// Current validation only checks MIME type patterns
const isValidType = allowedTypes.some(type => {
  if (type.endsWith('/*')) {
    return fileType.startsWith(type.slice(0, -1));
  }
  return fileType === type;
});
```

**Security Gaps:**
1. No verification that file content matches claimed MIME type
2. No magic number/file signature validation
3. No deep content inspection for malicious payloads
4. SVG files not parsed for dangerous elements

## Implementation Plan

### Phase 1: File Signature Validation Library (Days 1-2)

#### Step 1.1: Create Core Validation Utility

**File:** `lib/security/file-signature-validator.ts`

**Features:**
- Binary header inspection for common file types
- Magic number validation database
- File structure integrity checks
- Performance-optimized validation (header-only for most checks)

**File Signatures Database:**
```typescript
const FILE_SIGNATURES = {
  // Images
  'image/png': [{ offset: 0, signature: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] }],
  'image/jpeg': [
    { offset: 0, signature: [0xFF, 0xD8, 0xFF, 0xE0] },
    { offset: 0, signature: [0xFF, 0xD8, 0xFF, 0xE1] },
    { offset: 0, signature: [0xFF, 0xD8, 0xFF, 0xE8] }
  ],
  'image/webp': [
    { offset: 0, signature: [0x52, 0x49, 0x46, 0x46] }, // RIFF
    { offset: 8, signature: [0x57, 0x45, 0x42, 0x50] }  // WEBP
  ],
  'image/gif': [
    { offset: 0, signature: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61] }, // GIF87a
    { offset: 0, signature: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61] }  // GIF89a
  ],
  
  // Videos
  'video/mp4': [
    { offset: 4, signature: [0x66, 0x74, 0x79, 0x70] }, // ftyp
  ],
  'video/webm': [
    { offset: 0, signature: [0x1A, 0x45, 0xDF, 0xA3] }, // EBML header
  ],
  
  // Documents
  'application/pdf': [
    { offset: 0, signature: [0x25, 0x50, 0x44, 0x46] }, // %PDF
  ]
};
```

**Core Functions:**
```typescript
export interface ValidationResult {
  isValid: boolean;
  detectedType: string | null;
  confidence: number;
  errors: string[];
  securityFlags: string[];
}

export function validateFileSignature(
  buffer: ArrayBuffer, 
  claimedMimeType: string
): ValidationResult;

export function detectFileTypeFromSignature(
  buffer: ArrayBuffer
): string | null;

export function isValidFileStructure(
  buffer: ArrayBuffer, 
  mimeType: string
): boolean;
```

#### Step 1.2: Advanced Content Validation

**SVG Security Validation:**
```typescript
export function validateSVGContent(svgContent: string): {
  isSecure: boolean;
  threats: string[];
  sanitized?: string;
} {
  const threats: string[] = [];
  
  // Check for script tags
  if (/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi.test(svgContent)) {
    threats.push('Contains script tags');
  }
  
  // Check for javascript: URLs
  if (/javascript:/gi.test(svgContent)) {
    threats.push('Contains javascript: URLs');
  }
  
  // Check for event handlers
  if (/on\w+\s*=/gi.test(svgContent)) {
    threats.push('Contains event handlers');
  }
  
  return {
    isSecure: threats.length === 0,
    threats,
    sanitized: threats.length > 0 ? sanitizeSVG(svgContent) : undefined
  };
}
```

**Image Metadata Validation:**
```typescript
export function validateImageMetadata(buffer: ArrayBuffer, mimeType: string): {
  hasSuspiciousMetadata: boolean;
  issues: string[];
  shouldStrip: boolean;
} {
  // Implementation for EXIF data inspection
  // Check for embedded files, suspicious metadata
  // Validate image dimensions vs declared size
}
```

### Phase 2: Enhanced Upload Service Integration (Days 3-4)

#### Step 2.1: Extend SimpleUploadService

**File:** `lib/r2/simple-upload-service.ts`

**Enhanced Validation Method:**
```typescript
private async validateFileAdvanced(
  file: File | Buffer, 
  options: ValidationOptions = {}
): Promise<ValidationResult> {
  // Read file header for signature validation
  const buffer = file instanceof File 
    ? await file.slice(0, 8192).arrayBuffer() 
    : file.slice(0, 8192);
  
  // Perform signature validation
  const signatureResult = validateFileSignature(
    buffer, 
    file instanceof File ? file.type : options.expectedMimeType
  );
  
  if (!signatureResult.isValid) {
    throw new FileTypeError(
      options.allowedTypes || [], 
      file instanceof File ? file.type : 'unknown',
      {
        reason: 'File signature mismatch',
        detectedType: signatureResult.detectedType,
        securityFlags: signatureResult.securityFlags
      }
    );
  }
  
  // Additional content validation for specific types
  if (file instanceof File && file.type === 'image/svg+xml') {
    const svgContent = await file.text();
    const svgValidation = validateSVGContent(svgContent);
    
    if (!svgValidation.isSecure) {
      throw new SecurityValidationError(
        'SVG contains potentially dangerous content',
        svgValidation.threats
      );
    }
  }
  
  return signatureResult;
}
```

#### Step 2.2: Update Schema Validators

**File:** `lib/schemas/storage.ts`

**Enhanced Video Schema:**
```typescript
export const VideoFileSchema = z.object({
  file: z.instanceof(File)
    .refine(file => file.size > 0, 'File cannot be empty')
    .refine(file => file.size <= 500 * 1024 * 1024, 'File too large (max 500MB)')
    .refine(async file => {
      // Binary signature validation
      const buffer = await file.slice(0, 32).arrayBuffer();
      const validation = validateFileSignature(buffer, file.type);
      return validation.isValid;
    }, 'Invalid video file format')
    .refine(file => {
      const allowedTypes = ['video/mp4', 'video/webm', 'video/mov'];
      return allowedTypes.includes(file.type);
    }, 'Unsupported video format'),
});
```

**File:** `lib/schemas/client-logo.ts`

**Enhanced Logo Schema:**
```typescript
export const ClientLogoSchema = z.object({
  logo: z.instanceof(File)
    .refine(file => file.size <= 1024 * 1024, 'Logo must be under 1MB')
    .refine(async file => {
      if (file.type === 'image/svg+xml') {
        const content = await file.text();
        const svgValidation = validateSVGContent(content);
        return svgValidation.isSecure;
      }
      
      // Binary validation for other image types
      const buffer = await file.slice(0, 32).arrayBuffer();
      const validation = validateFileSignature(buffer, file.type);
      return validation.isValid;
    }, 'Invalid or unsafe image file'),
});
```

### Phase 3: API Route Enhancements (Days 5-6)

#### Step 3.1: Upload Route Security

**File:** `app/api/admin/clients/upload-logo/route.ts`

**Enhanced Validation:**
```typescript
export async function POST(request: NextRequest) {
  try {
    // ... existing auth code ...
    
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided', code: 'NO_FILE_PROVIDED' },
        { status: 400 }
      );
    }
    
    // Advanced file validation before upload
    try {
      const buffer = await file.slice(0, 8192).arrayBuffer();
      const validation = await validateFileSignature(buffer, file.type);
      
      if (!validation.isValid) {
        console.warn('File validation failed:', {
          filename: file.name,
          claimedType: file.type,
          detectedType: validation.detectedType,
          errors: validation.errors,
          securityFlags: validation.securityFlags,
          timestamp: new Date().toISOString()
        });
        
        return NextResponse.json(
          { 
            error: 'File validation failed',
            code: 'INVALID_FILE_SIGNATURE',
            details: {
              claimedType: file.type,
              detectedType: validation.detectedType,
              issues: validation.errors
            }
          },
          { status: 400 }
        );
      }
      
      // SVG-specific validation
      if (file.type === 'image/svg+xml') {
        const svgContent = await file.text();
        const svgValidation = validateSVGContent(svgContent);
        
        if (!svgValidation.isSecure) {
          console.warn('SVG security validation failed:', {
            filename: file.name,
            threats: svgValidation.threats,
            timestamp: new Date().toISOString()
          });
          
          return NextResponse.json(
            { 
              error: 'SVG file contains potentially dangerous content',
              code: 'UNSAFE_SVG_CONTENT',
              details: { threats: svgValidation.threats }
            },
            { status: 400 }
          );
        }
      }
      
    } catch (validationError) {
      console.error('Advanced validation error:', validationError);
      return NextResponse.json(
        { 
          error: 'File validation failed',
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      );
    }
    
    // ... rest of existing upload logic ...
  } catch (error) {
    // ... existing error handling ...
  }
}
```

### Phase 4: Security Configuration & Testing (Day 7)

#### Step 4.1: Security Configuration

**File:** `lib/security/file-validation-config.ts`

```typescript
export interface SecurityLevel {
  enforceSignatureValidation: boolean;
  allowSVGUploads: boolean;
  stripImageMetadata: boolean;
  maxFileHeaderSize: number;
  enableContentInspection: boolean;
}

export const SECURITY_LEVELS: Record<string, SecurityLevel> = {
  strict: {
    enforceSignatureValidation: true,
    allowSVGUploads: false,
    stripImageMetadata: true,
    maxFileHeaderSize: 8192,
    enableContentInspection: true,
  },
  moderate: {
    enforceSignatureValidation: true,
    allowSVGUploads: true,
    stripImageMetadata: true,
    maxFileHeaderSize: 4096,
    enableContentInspection: true,
  },
  permissive: {
    enforceSignatureValidation: false,
    allowSVGUploads: true,
    stripImageMetadata: false,
    maxFileHeaderSize: 1024,
    enableContentInspection: false,
  },
};

export const getCurrentSecurityLevel = (): SecurityLevel => {
  const level = process.env.FILE_VALIDATION_SECURITY_LEVEL || 'moderate';
  return SECURITY_LEVELS[level] || SECURITY_LEVELS.moderate;
};
```

#### Step 4.2: Comprehensive Testing

**File:** `lib/security/__tests__/file-signature-validator.test.ts`

```typescript
describe('File Signature Validator', () => {
  test('validates PNG signature correctly', async () => {
    const pngBuffer = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
    const result = validateFileSignature(pngBuffer.buffer, 'image/png');
    
    expect(result.isValid).toBe(true);
    expect(result.detectedType).toBe('image/png');
  });
  
  test('rejects spoofed file types', async () => {
    const pngBuffer = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
    const result = validateFileSignature(pngBuffer.buffer, 'video/mp4');
    
    expect(result.isValid).toBe(false);
    expect(result.detectedType).toBe('image/png');
    expect(result.errors).toContain('MIME type mismatch');
  });
  
  test('detects malicious SVG content', () => {
    const maliciousSVG = '<svg><script>alert("xss")</script></svg>';
    const result = validateSVGContent(maliciousSVG);
    
    expect(result.isSecure).toBe(false);
    expect(result.threats).toContain('Contains script tags');
  });
});
```

## Security Benefits

### Immediate Improvements

1. **Signature Validation:** Prevents MIME type spoofing attacks
2. **Content Inspection:** Detects malicious payloads in legitimate file formats
3. **SVG Security:** Eliminates XSS vectors in SVG uploads
4. **Metadata Stripping:** Removes potentially dangerous embedded data

### Long-term Security Posture

1. **Defense in Depth:** Multiple validation layers for comprehensive protection
2. **Monitoring:** Enhanced logging for security incident detection
3. **Flexibility:** Configurable security levels for different environments
4. **Compliance:** Meets industry best practices for file upload security

## Deployment Strategy

### Phase 1: Development Environment
- Deploy with strict security level for testing
- Comprehensive validation of all existing upload flows
- Performance testing with large files

### Phase 2: Staging Environment
- Deploy with moderate security level
- Integration testing with real-world file uploads
- User acceptance testing for upload workflows

### Phase 3: Production Rollout
- Gradual deployment with feature flags
- Monitor error rates and performance impact
- Rollback capability if issues detected

## Monitoring & Alerting

### Security Metrics
- File validation failure rates
- MIME type mismatch incidents
- SVG security violations
- Performance impact measurements

### Alert Conditions
- High rate of validation failures (potential attack)
- Repeated failures from same IP/user
- New file signature patterns detected
- Performance degradation beyond thresholds

## Maintenance & Updates

### Regular Updates
- File signature database updates for new formats
- Security pattern updates for emerging threats
- Performance optimizations based on usage patterns

### Monitoring
- Quarterly security assessment reviews
- Annual penetration testing
- Continuous performance monitoring

---

**Implementation Timeline:** 7 days  
**Testing Timeline:** 2 days  
**Deployment Timeline:** 3 days  
**Total Project Duration:** 12 days